syntax = "proto3";

package node;

option go_package = "./proto";

// Basic RPC interface for chorus nodes
service NodeService {
  // Ping exchanges peer information for gossip
  rpc Ping(PingRequest) returns (PingResponse);

  // Fetch returns the owner of a key (for routing)
  rpc Fetch(FetchRequest) returns (FetchResponse);

  // Put stores a value for a key (must be sent to owner node)
  rpc Put(PutRequest) returns (PutResponse);

  // Get retrieves a value for a key (must be sent to owner node)
  rpc Get(GetRequest) returns (GetResponse);

  // Replicate stores a value directly (used by primary to replicate to secondaries)
  rpc Replicate(ReplicateRequest) returns (ReplicateResponse);

  // Echo sends a message and gets a response
  rpc Echo(EchoRequest) returns (EchoResponse);

  // SubmitJob enqueues a job for scheduling
  rpc SubmitJob(SubmitJobRequest) returns (SubmitJobResponse);

  // GetJobStatus returns the current status of a job
  rpc GetJobStatus(JobStatusRequest) returns (JobStatusResponse);

  // ListJobs returns a summary of all jobs known to the scheduler
  rpc ListJobs(ListJobsRequest) returns (ListJobsResponse);

  // RunJob submits a job and streams output back to the client
  rpc RunJob(RunJobRequest) returns (stream RunJobResponse);
}

// PeerInfo contains information about a peer node
message PeerInfo {
  string id = 1;        // node ID (e.g., "node1")
  string addr = 2;      // address (e.g., "localhost:8010")
  int64 heartbeat = 3;  // heartbeat counter
}

message PingRequest {
  string node_id = 1;
  repeated PeerInfo peers = 2;  // all known peers including self
}

message PingResponse {
  string node_id = 1;
  int64 timestamp = 2;
  repeated PeerInfo peers = 3;  // merged peer info
}

message FetchRequest {
  string key = 1;
}

message FetchResponse {
  string owner_id = 1;      // node ID that owns this key
  string owner_addr = 2;    // address of the owner
  uint32 ring_fingerprint = 3;  // hash of membership - same fingerprint = same ring
}

message EchoRequest {
  string node_id = 1;
  string message = 2;
  int32 hop_count = 3;
}

message EchoResponse {
  string node_id = 1;
  string message = 2;
  int32 hop_count = 3;
}

message PutRequest {
  string key = 1;
  bytes value = 2;
}

message PutResponse {
  bool stored = 1;                          // true if this node stored the value
  string owner_id = 2;                      // if not stored: the actual owner (primary)
  string owner_addr = 3;                    // if not stored: owner's address for redirect
  repeated ReplicaStatus replica_status = 4; // status per replica (for replication results)
}

message ReplicaStatus {
  string node_id = 1;
  bool success = 2;
  string error = 3;
}

message ReplicateRequest {
  string key = 1;
  bytes value = 2;
}

message ReplicateResponse {
  bool stored = 1;
}

message GetRequest {
  string key = 1;
}

message GetResponse {
  bool found = 1;           // true if key exists on this node
  bytes value = 2;          // the value (if found)
  string owner_id = 3;      // if wrong node: the actual owner
  string owner_addr = 4;    // if wrong node: owner's address for redirect
}

// --- Scheduler messages ---

message PromptContinuation {
  string prompt = 1;          // the user prompt to continue from
}

message JobType {
  oneof type {
    PromptContinuation prompt_continuation = 100;
  }
}

message SubmitJobRequest {
  string id = 1;            // client-provided job ID
  int32 priority = 2;       // lower value = higher priority
  int32 cost = 3;           // capacity units consumed
  JobType job_type = 4;
}

message SubmitJobResponse {
  string id = 1;            // job ID
  string status = 2;        // "pending" or "rejected"
  string reason = 3;        // rejection reason (empty if accepted)
}

message JobStatusRequest {
  string id = 1;            // job ID to look up
}

message JobStatusResponse {
  string id = 1;
  string status = 2;        // "pending", "running", "completed", "rejected", "unknown"
  string worker_id = 3;     // assigned worker (empty if not running)
  int32 priority = 4;
  int32 cost = 5;
}

message ListJobsRequest {}

message ListJobsResponse {
  repeated JobSummary jobs = 1;
}

message JobSummary {
  string id = 1;
  string status = 2;
  int32 priority = 3;
  int32 cost = 4;
  string worker_id = 5;
}

// --- Streaming job execution ---

message RunJobRequest {
  string id = 1;            // client-provided job ID
  int32 priority = 2;       // lower value = higher priority
  int32 cost = 3;           // capacity units consumed
  JobType job_type = 4;
}

message RunJobResponse {
  string job_id = 1;
  oneof event {
    JobQueued queued = 100;
    JobStarted started = 101;
    OutputChunk chunk = 102;
    JobCompleted completed = 103;
    JobFailed failed = 104;
  }
}

message JobQueued {}

message JobStarted {
  string worker_id = 1;
}

message OutputChunk {
  string token = 1;         // a token or chunk of text
}

message JobCompleted {}

message JobFailed {
  string error = 1;
}
